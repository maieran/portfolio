<h1>My Journey into DevOps</h1>
<h2>Big Thanks to Imran Teli and his team, where I was learning from:</h2>
<a href="https://www.udemy.com/course/devopsprojects/"><b>Udemy Course</b></a>
<hr />


<img src="../assets/images/DevOps/DevOps with tech-stack.png" width="700" height="400"/>
<ol>
    <h3><li>VM Setup and Java Multi Tier Web Application:
    </li></h3>
    <p> The Java Multi-Tier Web Application (Java Application) integrates MySQL, MemCache, RabbitMQ, and Nginx. 
        Vagrant is used to set up the local environment, making it easy to understand and manage the interaction between the various technologies involved in the project.
    </p>

    <h3><li>
        Setup of AWS Cloud and Migration of the Multi Tier Web App into Cloud
    </li></h3>
    <p> The Java application, along with its supporting technologies, 
        has been migrated to AWS. Key components, including the Tomcat server, 
        RabbitMQ, MemCache, and MySQL, now run on EC2 instances. 
        The load balancing previously handled by Nginx is now managed by AWSâ€™s Elastic Load Balancer (ELB), and autoscaling is fully automated by AWS. 
        Shared storage is provided through S3 and EFS, and Route 53 coordinates the private DNS services, ensuring seamless communication across services.
    </p>

    <h3><li>
        Restructuring and Refactoring of Multi Tier Web Application in AWS
    </li></h3>
    <p> In aligning with PAAS/SAAS practices, the goal was to reduce reliance on EC2 instances and shift towards AWS-managed services. AWS Elastic Beanstalk was introduced to manage Tomcat, load balancing, and automatic scaling. Additionally, other AWS services were explored, including RDS for MySQL, Elastic Cache for Memcached, ActiveMQ as an alternative to RabbitMQ, Route 53 for DNS, and CloudFront for CDN.
    </p>

    <h3><li>
        Containerization of Java project using Docker
    </li></h3>
    <p>
       After setting up the Dockerhub and introduction into Docker registry and images, 
       here I have set up the dockerfiles for tomcat, MySQL and Nginx and together let it build and run by docker compose.
       By the end of the project, containerization steps for a microservices project have been prepared, where in the end from the docker files of the microservice app 
       where build and deployed to EC2 instances in the AWS cloud.

    </p>

    <h3>
        <li>
            Using Jenkins and Groovy Scripting for configuring CI/CD
        </li>
    </h3>
    <p>
        Having previous experience with CI/CD using Jenkins, I revisited Groovy scripting and pipeline setup to strengthen my skills. A key part of my training involved installing and configuring the Jenkins environment, as in most projects, these steps are typically completed long before new team members join.
    </p>

    <h3>
        <li>
           CI with Jenkins, Nexus and Slack with EC2<br/>
           Repeated same on AWS PAAS/SAAS services
        </li> 
    </h3>
    <p>
        In this project, a Multi-Tier Web Application was integrated using Jenkins for CI pipelines triggered by Git webhooks. 
        SonarQube ensured code quality, Nexus stored artifacts, and Slack notified team members of releases. 
        Initially running on AWS EC2 instances, the CI process later transitioned fully to AWS-managed services: AWS CodeCommit replaced GitHub, AWS CodeArtifact replaced Nexus, SonarCloud replaced SonarQube, and AWS CodeBuild handled code analysis and artifact creation, all within AWS CodePipeline. 
        Slack notifications were replaced by AWS SNS for streamlined alerts.
    </p>

    <h3>
        <li>
           CD of Java Web Application with EC2<br/>
           Repeated same on AWS with PAAS/SAAS services
        </li> 
    </h3>
    <p>
        This project aimed to build, test, and deploy a Java application using Bitbucket webhooks, Jenkins, and AWS EC2 instances. 
        Later, CD steps were transitioned to AWS-managed services: CodeCommit for version control, CodeArtifact for Maven dependencies, CodeBuild for application builds, and CodeDeploy for artifact storage, with deployment executed on AWS Elastic Beanstalk. 
        The application was connected to an RDS instance for the database. 
        Production tests were run using Selenium Test Suite with AWS CodeBuild, with results stored in an S3 bucket. 
        SonarCloud handled code analysis, and AWS CodePipeline replaced Jenkins, with AWS CodeBuild handling builds as Jenkins job equivalents.
    </p>


</ol>
